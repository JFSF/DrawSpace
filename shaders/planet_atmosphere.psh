/*
*                                                                          
* DrawSpace Rendering engine                                               
* Emmanuel Chaumont Copyright (c) 2013-2016                              
*                                                                          
* This file is part of DrawSpace.                                          
*                                                                          
*    DrawSpace is free software: you can redistribute it and/or modify     
*    it under the terms of the GNU General Public License as published by  
*    the Free Software Foundation, either version 3 of the License, or     
*    (at your option) any later version.                                   
*                                                                          
*    DrawSpace is distributed in the hope that it will be useful,          
*    but WITHOUT ANY WARRANTY; without even the implied warranty of        
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         
*    GNU General Public License for more details.                          
*                                                                          
*    You should have received a copy of the GNU General Public License     
*    along with DrawSpace.  If not, see <http://www.gnu.org/licenses/>.    
*
*/

float4 flags : register(c0);
	// .x -> fragment/layout relative altitude
	// .y -> patch sidelenght
	// .z -> fragment/layout ray
	// .w -> patch orientation enum integer

float4 flags2 : register(c1);
	// .x -> ht textures resol

float4 viewer_pos : register(c2); // pos camera par rapport au centre sphere




float4 flags7 : register(c7);
	// .x -> ambient light
	// .y -> color0 light
	// .z -> color1 light
	// .w -> color2 light

float4 ambient_color    : register(c8);

float4 light0_dir_local : register(c9);
float4 light0_dir_global : register(c10);
float4 light0_color     : register(c11);

float4 light1_dir_local : register(c12);
float4 light1_dir_global : register(c13);
float4 light1_color : register(c14);

float4 light2_dir_local : register(c15);
float4 light2_dir_global : register(c16);
float4 light2_color : register(c17);

float4 atmo_scattering_flag_0 : register(c18);
float4 atmo_scattering_flag_1 : register(c19);
float4 atmo_scattering_flag_2 : register(c20);
float4 atmo_scattering_flag_3 : register(c21);
float4 atmo_scattering_flag_4 : register(c22);
float4 atmo_scattering_flag_5 : register(c23);


struct PS_INTPUT
{
    float4 t0 : TEXCOORD0;
    float4 t1 : TEXCOORD1;
};

#include "spherelod_commons.hlsl"
#include "atmospheric_scattering.hlsl"

float4 ps_main( PS_INTPUT input ) : COLOR0
{
    float viewer_alt = length(viewer_pos) - atmo_scattering_flag_0.y;
    float atmo_thickness = atmo_scattering_flag_0.x - atmo_scattering_flag_0.y;

    float4 color;
    
    if(viewer_alt >= atmo_scattering_flag_5.x)
    {
        atmo_scattering_sampling_result sampling = skyfromspace_atmo_scattering_sampling(input.t0, input.t1, light0_dir_global);
        color.xyz = atmo_scattering_color_result(sampling, light0_dir_global);
        color.w = color.z;        
    }
    else
    {
        atmo_scattering_sampling_result sampling_up = skyfromspace_atmo_scattering_sampling(input.t0, input.t1, light0_dir_global);
           
        atmo_scattering_sampling_result sampling_down = skyfromatmo_atmo_scattering_sampling(input.t0, input.t1, light0_dir_global);

        float3 color_up;
        float3 color_down;

        color_up = atmo_scattering_color_result(sampling_up, light0_dir_global);

        color_down = atmo_scattering_color_result(sampling_down, light0_dir_global);

        float3 hdr_color_down = 1.0 - exp(-0.91 * color_down); // added S. O'Neil HDR correction

        float alt_factor1 = clamp((viewer_alt - atmo_thickness) / (atmo_scattering_flag_5.x - atmo_thickness), 0.0, 1.0);

        color.xyz = lerp(hdr_color_down, color_up, alt_factor1);

        float alt_factor2 = clamp(viewer_alt / atmo_scattering_flag_5.y, 0.0, 1.0);
        float atmo_alpha_alt = 1.0 - alt_factor2;

        // diminuer progressivement l'influence du bleu dans la composante alpha
        float blue = lerp(color.z, 1.0, atmo_alpha_alt);

        // ne commencer à laisser apparaitre les etoiles que lorsque le prodsca est tres proche de 0.0
        
        float atmo_alpha_dir = lerp(color.z, 1.0, atan(clamp(dot(light0_dir_global, normalize(viewer_pos)), 0.0, 1.0) * 4000.0) / 1.57);

        float atmo_alpha = atmo_alpha_dir * atmo_alpha_alt * blue; // moduler alpha avec le bleu et l'altitude et le prod sca vecteur lumiere

        color.w = lerp(atmo_alpha, color.z, alt_factor1);
    }
   
    return color;    
}
