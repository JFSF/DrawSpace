
float4 lacunarity: register(c0);

sampler2D TextureBuffer : register(s0);
sampler2D TextureMap : register(s1);
sampler2D TextureExp : register(s2);

struct PS_INTPUT 
{
	float4 Position : POSITION0;
	float4 TexCoord0: TEXCOORD0;
	float4 TexCoord1: TEXCOORD1;
};


double Noise_Lattice( int ix, double fx, int iy, double fy, int iz, double fz, int iw, double fw )
{
	// ECH : texture index mid interval -> 1 /2N, N = 256 ou N = 3
	double midinterval256 = 0.001953125; //1.0 / 512.0;
	double midinterval3 = 0.166666; //1.0 / 6.0;
	double index3 = 0.3333333; //1.0 / 3.0;
	double index256 = 0.00390625; //1.0 / 256.0;
	
	float4 maptextcoord = 0.0;
	float4 buffertextcoord = 0.0;

	int i;	
	int n[4] = { ix, iy, iz, iw };
	double f[4] = { fx, fy, fz, fw };
	
	int nIndex = 0;
	for( i = 0; i < 3; i++ )
	{
		int indexTemp = nIndex + n[i];		
		if( indexTemp > 255 )
		{
			indexTemp - 255;
		}
		maptextcoord[0] = ( index256 * indexTemp ) + midinterval256;
		
		if( maptextcoord[0] > 1.0 )
		{
			maptextcoord[0] -= 1.0;
		}
		else if( maptextcoord[0] < 0.0 )
		{
			maptextcoord[0] = 1.0 + maptextcoord[0];
		}

		maptextcoord[1] = 0.5;
		float4 mapval = tex2D( TextureMap, maptextcoord );
		nIndex = mapval.x * 255.0;
	}
	
	double fValue = 0.0;
	for( i = 0; i < 3; i++ )
	{ 
		buffertextcoord[0] = ( index256 * nIndex ) + midinterval256;
		buffertextcoord[1] = ( index3 * i ) + midinterval3;		
		double buffval = tex2D( TextureBuffer, buffertextcoord );
		fValue += ( buffval * f[i] );
	}
	return fValue;
}

double Noise_Noise( double3 f )
{
	
	int n[3];			// Indexes to pass to lattice function
	double r[3];		// Remainders to pass to lattice function
	double w[3];		// Cubic values to pass to interpolation function

	int i;
	for( i = 0; i < 3; i++ )
	{
        n[i] = floor( f[i] );		
		r[i] = f[i] - n[i];
		double temp = r[i];
        w[i] = temp * temp * ( 3.0 - ( 2.0 * temp ) );		
	}

	double fValue;
	
	fValue = lerp(lerp(lerp(Noise_Lattice(n[0], r[0], n[1], r[1], n[2], r[2], 0, 0.0),
							Noise_Lattice(n[0]+1, r[0]-1, n[1], r[1], n[2], r[2], 0, 0.0),
							w[0]),
						lerp(Noise_Lattice(n[0], r[0], n[1]+1, r[1]-1.0, n[2], r[2], 0, 0.0),
							Noise_Lattice(n[0]+1, r[0]-1, n[1]+1, r[1]-1.0, n[2], r[2], 0, 0.0),
							w[0]),
						w[1]),
					lerp(lerp(Noise_Lattice(n[0], r[0], n[1], r[1], n[2]+1, r[2]-1.0, 0, 0.0),
							Noise_Lattice(n[0]+1, r[0]-1, n[1], r[1], n[2]+1, r[2]-1.0, 0, 0.0),
							w[0]),
						lerp(Noise_Lattice(n[0], r[0], n[1]+1, r[1]-1.0, n[2]+1, r[2]-1.0, 0, 0.0),
							Noise_Lattice(n[0]+1, r[0]-1, n[1]+1, r[1]-1.0, n[2]+1, r[2]-1.0, 0, 0.0),
							w[0]),
						w[1]),
					w[2]);

	return clamp( -0.9999, 0.9999, fValue );
}


double Fractal_fBm( double3 f, double fOctaves )
{

	double midinterval128 = 0.00390625;
	double index128 = 0.0078125;
	float4 buffertextexp = 0.0;
    
	int i;
	// Initialize locals
	double fValue = 0.0;
	double3 fTemp;
	for( i = 0; i < 3; i++ )
	{
		fTemp[i] = f[i];
	}

	double expvVal;

	int nbOctaves = floor( fOctaves );		
	// Inner loop of spectral construction, where the fractal is built
	for( i = 0; i < nbOctaves; i++ )
	{
		buffertextexp[0] = ( index128 * i ) + midinterval128;
		expvVal = tex2D( TextureExp, buffertextexp );
		fValue += Noise_Noise( fTemp ) * expvVal;
				
		for( int j = 0; j < 3; j++ )
		{
			fTemp[j] *= lacunarity.x;
		}			
	}
	
	// Take care of remainder in fOctaves
	
	fOctaves -= nbOctaves;
	
	if( fOctaves > 0.0000006 )
	{
		fValue += fOctaves * Noise_Noise( fTemp ) * expvVal;
	}
	
	return clamp( -1.0, 1.0, fValue );	
}

float4 ps_main( PS_INTPUT input ) : COLOR0
{
	float4 color = 0;
		
	
	double3 f = 0.0;
	f[0] = lerp( -16.0, 16.0, input.TexCoord0.x );
	f[1] = lerp( -16.0, 16.0, input.TexCoord0.y );
	f[2] = 1.0;

	

	//float res = Noise_Noise( f );
	float res = Fractal_fBm( f, 5.0 );

	color = ( res * 0.5 ) + 0.5;
	
	return color;
}
