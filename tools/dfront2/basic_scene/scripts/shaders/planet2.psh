
float4 flags : register(c0);
	// .x -> relative altitude
	// .y -> patch sidelenght
	// .z -> planet ray
	// .w -> patch orientation enum integer

float4 flags2 : register(c1);
	// .x -> ht textures resol

float4 flags6 : register(c6);
	// .x -> resol atlas textures splatting
	// .y -> transition texture globale/texture splatting : borne sup
	// .z -> transition texture globale/texture splatting : borne inf


float4 light0_dir_local : register(c7);

sampler2D Texture0 : register(s0);
sampler2D Texture1 : register(s1);
sampler2D Texture2 : register(s2);

struct PS_INTPUT
{	
	float4 TexCoord0: TEXCOORD0;
	float4 TexCoord1: TEXCOORD1;
	float4 TexCoord2: TEXCOORD2;
};

float2 compute_sampling_params( float p_param, float p_interval )
{
	float3 res;
	
	float t_offset = p_interval * floor( p_param / p_interval );

	float w2 = ( p_param - t_offset ) / p_interval;

	res.x = w2;
	res.y = t_offset;

	return res;
}

float4 splatting_color( float4 p_textcoords, float p_temperature, float p_humidity )
{

	// contracter legerement les coords patch pour eviter les effets de bords de couleurs
	float4 patch_coords = ( 0.98 * ( p_textcoords - 0.5 ) ) + 0.5;

	//float interval = 1.0 / 16;
	float interval = 1.0 / flags6.x;

	float limit_up = 1.0 - interval;

	float t, h;

	t = clamp( p_temperature, 0.0, 0.999 );
	h = clamp( p_humidity, 0.0, 0.999 );
	   			
	float2 temperature_sampling = compute_sampling_params( clamp( t, 0.0, 1.0 - ( 4.0 * interval ) ), interval );
	float2 humidity_sampling = compute_sampling_params( clamp( h, 0.0, 1.0 - ( 4.0 * interval ) ), interval );


	float4 res_color = 0.0;


	bool delta_u = false;
	bool delta_v = false;
	
	if( t < limit_up )
	{
		delta_u = true;		
	}
	else
	{
		delta_u = false;
	}

	if( h < limit_up )
	{
		delta_v = true;
	}
	else
	{
		delta_v = false;
	}

	if( delta_u && delta_v )
	{
		float4 coords_1 = patch_coords * interval;
		coords_1.x += temperature_sampling.y;
		coords_1.y += humidity_sampling.y;

		float4 coords_2 = patch_coords * interval;
		coords_2.x += temperature_sampling.y + interval;
		coords_2.y += humidity_sampling.y;

		float4 coords_3 = patch_coords * interval;
		coords_3.x += temperature_sampling.y + interval;
		coords_3.y += humidity_sampling.y + interval;

		float4 coords_4 = patch_coords * interval;
		coords_4.x += temperature_sampling.y;
		coords_4.y += humidity_sampling.y + interval;

		float4 color_1 = tex2D( Texture2, coords_1 );
		float4 color_2 = tex2D( Texture2, coords_2 );
		float4 color_3 = tex2D( Texture2, coords_3 );
		float4 color_4 = tex2D( Texture2, coords_4 );

		// calcul des poids splatting : calcul d'un "vecteur des distances"

		float4 distances;

		float2 point;
		point.x = temperature_sampling.x;
		point.y = humidity_sampling.x;

		float2 point_1;
		float2 point_2;
		float2 point_3;
		float2 point_4;

		point_1.x = 0.0;
		point_1.y = 0.0;

		point_2.x = 1.0;
		point_2.y = 0.0;

		point_3.x = 1.0;
		point_3.y = 1.0;

		point_4.x = 0.0;
		point_4.y = 1.0;

		distances.x = 1.0 - clamp( sqrt( ( point_1.x - point.x ) * ( point_1.x - point.x ) + ( point_1.y - point.y ) * ( point_1.y - point.y ) ), 0.0, 1.0 );
		distances.y = 1.0 - clamp( sqrt( ( point_2.x - point.x ) * ( point_2.x - point.x ) + ( point_2.y - point.y ) * ( point_2.y - point.y ) ), 0.0, 1.0 );
		distances.z = 1.0 - clamp( sqrt( ( point_3.x - point.x ) * ( point_3.x - point.x ) + ( point_3.y - point.y ) * ( point_3.y - point.y ) ), 0.0, 1.0 );
		distances.w = 1.0 - clamp( sqrt( ( point_4.x - point.x ) * ( point_4.x - point.x ) + ( point_4.y - point.y ) * ( point_4.y - point.y ) ), 0.0, 1.0 );
		
		res_color = distances.x * color_1 + distances.y * color_2 
					+ distances.z * color_3 + distances.w * color_4;
	}
	else if( delta_u && !delta_v )
	{
		float4 coords_1 = patch_coords * interval;
		coords_1.x += temperature_sampling.y;
		coords_1.y += humidity_sampling.y;

		float4 coords_2 = patch_coords * interval;
		coords_2.x += temperature_sampling.y + interval;
		coords_2.y += humidity_sampling.y;

		float4 color_1 = tex2D( Texture2, coords_1 );
		float4 color_2 = tex2D( Texture2, coords_2 );
		
		res_color = ( ( 1.0 - temperature_sampling.x ) * color_1 ) + ( temperature_sampling.x * color_2 );
	}
	else if( !delta_u && delta_v )
	{
		float4 coords_1 = patch_coords * interval;
		coords_1.x += temperature_sampling.y;
		coords_1.y += humidity_sampling.y;

		float4 coords_4 = patch_coords * interval;
		coords_4.x += temperature_sampling.y;
		coords_4.y += humidity_sampling.y + interval;

		float4 color_1 = tex2D( Texture2, coords_1 );
		float4 color_4 = tex2D( Texture2, coords_4 );

		res_color = ( ( 1.0 - humidity_sampling.x ) * color_1 ) + ( humidity_sampling.x * color_4 );
	}
	else
	{
		float4 coords_1 = patch_coords * interval;
		coords_1.x += temperature_sampling.y;
		coords_1.y += humidity_sampling.y;

		float4 color_1 = tex2D( Texture2, coords_1 );
		
		res_color = color_1;	
	}

	return res_color;

}

float4 ps_main( PS_INTPUT input ) : COLOR0
{
	float4 final_color = 0.0;

	float4 temp_humidity = tex2D( Texture0, input.TexCoord0 );


	float lim_sup = flags6.y;
	float lim_inf = flags6.z;


	bool sea = false;

	if( flags.x <= lim_inf )
	{
		// si altitude relative a un certain seuil

		// regarder l'altitude vertex interpole pour determiner si rendu mer
		if( input.TexCoord0.z <= 0.0 ) // altitude vertex (interpolee)
		{
			sea = true;
		}
	}
	else
	{
		// si altitude relative > 1.5

		// regarder texture donnees temperature/humidite pour determiner si rendu mer
		if( temp_humidity.z > 0.0 )
		{
			sea = true;
		}
	}


	float3 avg;

	if( !sea )
	{
	
		float texel_size = 1.0 / flags2.x;

		float2 left_coords = input.TexCoord0;
		left_coords.x -= texel_size;

		float2 right_coords = input.TexCoord0;
		right_coords.x += texel_size;

		float2 up_coords = input.TexCoord0;
		up_coords.y -= texel_size;

		float2 down_coords = input.TexCoord0;
		down_coords.y += texel_size;

		float4 temp_humidity_left = tex2D( Texture0, left_coords );
		float4 temp_humidity_right = tex2D( Texture0, right_coords );
		float4 temp_humidity_up = tex2D( Texture0, up_coords );
		float4 temp_humidity_down = tex2D( Texture0, down_coords );



		float point_alt_center = temp_humidity.w;

		float point_alt_left = temp_humidity_left.w;
		float point_alt_right = temp_humidity_right.w;
		float point_alt_up = temp_humidity_up.w;
		float point_alt_down = temp_humidity_down.w;

		float real_texel_size = 100.0; // controle de "l'intensité" du relief bump mapping

		float3 vec_left;
		vec_left.x = -real_texel_size;
		vec_left.y = 0.0;
		vec_left.z = ( point_alt_left - point_alt_center );

		float3 vec_right;
		vec_right.x = real_texel_size;
		vec_right.y = 0.0;
		vec_right.z = ( point_alt_right - point_alt_center );

		float3 vec_up;
		vec_up.x = 0.0;
		vec_up.y = -real_texel_size;
		vec_up.z = ( point_alt_up - point_alt_center );

		float3 vec_down;
		vec_down.x = 0.0;
		vec_down.y = real_texel_size;
		vec_down.z = ( point_alt_down - point_alt_center );

	
		float3 vec1 = normalize( cross( vec_right, vec_down ) );
		float3 vec2 = normalize( cross( vec_down, vec_left ) );
		float3 vec3 = normalize( cross( vec_left, vec_up ) );
		float3 vec4 = normalize( cross( vec_up, vec_right ) );

		avg = normalize( 0.25 * ( vec1 + vec2 + vec3 + vec4 ) );	
	}
	





	float3 texel_pos = 0.0;

	// x - u -> passage de [0, 1] à [-1, 1]
	texel_pos.x = ( 2.0 * input.TexCoord2.x ) - 1.0;

	// y - v -> passage de [0, 1] à [+1,-1]
	texel_pos.y = -( ( 2.0 * input.TexCoord2.y ) - 1.0 );

	texel_pos.z = 1.0;


	if( !sea )
	{
		//float k = 0.666;  // poids du vecteur bump mapping

		float k = clamp( ( 1.5708 - atan( 30.0 * ( flags.x - 1.0 ) ) ), 0.01, 0.4 );

		texel_pos.x += k * avg.x;
		texel_pos.y += k * avg.y;

		texel_pos = normalize( texel_pos );
	}




	float3 texel_pos2;

	if( 0.0 == flags.w ) // front
	{
		texel_pos2.x = texel_pos.x;
		texel_pos2.y = texel_pos.y;
		texel_pos2.z = texel_pos.z;   
	}
	else if( 1.0 == flags.w ) // rear
	{
		texel_pos2.x = -texel_pos.x;
		texel_pos2.y = texel_pos.y;
		texel_pos2.z = -texel_pos.z;   
	}
	else if( 2.0 == flags.w ) // left
	{
		texel_pos2.x = -texel_pos.z;
		texel_pos2.y = texel_pos.y;
		texel_pos2.z = texel_pos.x;   
	}
	else if( 3.0 == flags.w ) // right
	{
		texel_pos2.x = texel_pos.z;
		texel_pos2.y = texel_pos.y;
		texel_pos2.z = -texel_pos.x;   
	}
	else if( 4.0 == flags.w ) // top
	{
		texel_pos2.x = texel_pos.x;
		texel_pos2.y = texel_pos.z;
		texel_pos2.z = -texel_pos.y;   
	}
	else //if( 5.0 == flags.w ) // bottom
	{
		texel_pos2.x = texel_pos.x;
		texel_pos2.y = -texel_pos.z;
		texel_pos2.z = texel_pos.y;
	}

	float xtemp = texel_pos2.x;
	float ytemp = texel_pos2.y;
	float ztemp = texel_pos2.z;

	texel_pos2.x = xtemp * sqrt( 1.0 - ytemp * ytemp * 0.5 - ztemp * ztemp * 0.5 + ytemp * ytemp * ztemp * ztemp / 3.0 );
	texel_pos2.y = ytemp * sqrt( 1.0 - ztemp * ztemp * 0.5 - xtemp * xtemp * 0.5 + xtemp * xtemp * ztemp * ztemp / 3.0 );
	texel_pos2.z = ztemp * sqrt( 1.0 - xtemp * xtemp * 0.5 - ytemp * ytemp * 0.5 + xtemp * xtemp * ytemp * ytemp / 3.0 );



	float3 light_dir;
	light_dir = light0_dir_local;

	float lf = clamp( dot( texel_pos2, light_dir ), 0.0, 1.0 );	


	////////////////////////////////////////////////////////////////////////////////////
	



	if( flags.x > 0.0 && flags.x <= lim_inf )
	{			
		if( sea ) 
		{
			final_color.z = 1.0;
		}
		else
		{
			final_color = splatting_color( input.TexCoord1, temp_humidity.x, temp_humidity.y );	
		}

	}
	else if( flags.x > lim_inf && flags.x <= lim_sup )
	{
		float4 color_splat = splatting_color( input.TexCoord1, temp_humidity.x, temp_humidity.y );
		float4 color_pixel = tex2D( Texture1, temp_humidity );

		if( sea )
		{
			final_color.z = 1.0;
		}
		else
		{
			final_color = lerp( color_splat, color_pixel, ( flags.x - lim_inf ) / ( lim_sup - lim_inf ) );
		}
	}
	else
	{		
		if( sea )
		{
			final_color.z = 1.0;
		}
		else
		{
			final_color = tex2D( Texture1, temp_humidity );
		}
	}
	
	

	return final_color * lf;
	//return final_color;
}
